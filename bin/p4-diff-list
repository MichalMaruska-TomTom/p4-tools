#!/bin/zsh -eu
unsetopt FUNCTION_ARGZERO

# todo:  -c should be -c CL, and --color or -C.

# Produce a PATCH given by the pending changelist.
# todo:  exit if the CL is wrong.

function die(){
    echo $1>&2
    exit 1
}

usage() {
cat <<EOF
usage: `basename $0` [+-c] [-d] [-v] [--] ARGS...
-c  colordiff
-d  plain diff, no doctoring
-v  verbose
EOF
}

plain_diff=0
VERBOSE=n
while getopts :cdhv OPT; do
    case $OPT in
	c|+c)
	    P4DIFF=colordiff
	    ;;
	d|+d)
	    plain_diff=1
	    ;;
	h)
	    usage
	    exit 0
	    ;;
	v)
	    VERBOSE=y
	    ;;
	*)
	    usage >&2
	    exit 2
    esac
done

shift `expr $OPTIND - 1`
OPTIND=1

if [ $# -lt 1 ]
then
    die "usage: $0 CL-number"
fi


SKIP_HEADER_AWK=${P4SHARE:-~/repo/p4-tools/share/}/skip-header.awk
SKIP_MIDDLE_FILE=${P4SHARE:-~/repo/p4-tools/share/}/skip-header2.awk
SKIP_NULL_HEADER=${P4SHARE:-~/repo/p4-tools/share/}/skip-null-header.awk

# The produced patch contains a comment with the CL description.
echo "# $1"
echo -n "#"; p4-message $1

# bash returns 1 string w/o the newlines!
# zsh with newlines !!
cl_info=$(p4 opened -c $1)
cl_files=$(echo $cl_info| grep -F  -e '- edit change '|sed -e 's/#.*$//')
files_added=($(echo $cl_info| grep  -F  -e '- add change '|sed -e 's/#.*$//'))
files_deleted=($(echo $cl_info| grep  -F  -e ' - delete change '|sed -e 's/#.*$//'))

if [ $VERBOSE = "y" ]; then
    {
    echo "p4 opened returned: "
    echo $cl_info
    echo "========"
    echo $cl_files >&2
    } >&2
fi
# export sane default. Note that the (_short_) options are for
# diff(1) compatible!
P4DIFF=${P4DIFF:-diff}  \
    echo $cl_files |\
    p4 -x - diff -d${P4DIFFOPTIONS:-bBNup} |\
    if [ $plain_diff = 0 ]; then
       awk -f $SKIP_HEADER_AWK |\
       awk -f $SKIP_MIDDLE_FILE
    else
       cat
    fi

# strip the +++ --- lines after ===

# -d-unified
# -b -B -N --show-c-function
# p4 depot ... root



# ADDED files: diff with  /dev/null
# =====
for file ($files_added)
do
    depotfile=$(p4 where $file| cut -f 1 -d ' ')
    local_file=$(p4 where $file| cut -f 3 -d ' ')
    {
      # no more needed:, or is it?
	echo "==== ${depotfile}#0 - $local_file ====";
	# :-bB
	# make it relative filename:
	diff -${P4DIFFOPTIONS-Nup} /dev/null $local_file |\
        if [ $plain_diff = 0 ]; then
	    awk -f $SKIP_NULL_HEADER
	else
	    cat;
	fi
    }
    #xargs --replace={} --max-lines 1 diff {} /dev/null
done

for file ($files_deleted)
do
    #p4 print to recover the original contents:

    depotfile=$(p4 where $file| cut -f 1 -d ' ')
    local_file=$(p4 where $file| cut -f 3 -d ' ')

    # no. keep it absolute.
    # local_file=${local_file:$#root}

    # might have to create dirs?
    if [ ! -s $local_file ]; then
	mkdir -p "$(dirname $local_file)"
	p4 print $local_file > $local_file

	if [ $VERBOSE = "y" ]; then
	    echo "recovered the original content into $local_file">&2;
	fi
    fi

    if [ $VERBOSE = "y" ]; then echo "next file: $local_file">&2; fi

    {
      # no more needed:, or is it?
	# not this:
	# echo "==== ${depotfile}#0 - $local_file ====";

	# :-bB
	# make it relative filename:
	diff -${P4DIFFOPTIONS-Nup} $local_file /dev/null |\
        if [ $plain_diff = 0 ]; then
	    awk -f $SKIP_NULL_HEADER
	else
	    cat;
	fi
    }
    rm -f $local_file
done
